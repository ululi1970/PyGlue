# PyGlue
A simple C++ library to pass variables, run code and retrieve data on a Python interpreter from within a C++ 
See the header file and the main.cpp for examples. 
This class relies on C++11 features. Depending on the compiler, 
the flag -std=c++11 or equivalent must be set.  
While the user is to translate C++ types into whatever Python types she chooses, here we focus on valarrays 
represented as numpys
A simple example: Suppose we want to perform Z=X^M+A*Y^N, where A is double, and X,Y,Z are valarray<double>s and 
M,N are integers. In Python this would be accomplished writing a py file (call it ham.py)

import PyGlue as pg # this imports numpys

def spam(X,Y,Z,M,N,A):
    x,y,z=pg.ValarrayToNumpy(X),pg.ValarrayToNumpy(Y),pg.ValarrayToNumpy(Z)
    z=np.power(x,M[0])+A[0]*np.power(y,N)


On the C++ side, 

{....
Py Python; 
valarray<float> X,Y,Z; 
int M,N;
float A;
... // init the variables

Python.PythonFunction("ham","spam",X,Y,Z,M,N,A);

... // Do something with Z

}

# Design considerations

The library is designed to minimize deep copies. To this effect, only basic types (int, float and double) are passed by value, on the assumption that nobody would want to set up the machinery to manipulate simple types. Data rich structures (e.g., valarrays) are instead aliased into numpys, without deep copies. 

# Memory management

Python's memory is managed by an automatic garbage collector. Any object in Python is reference counted: when the reference count hits zero, the garbage collector gets to work. C++ is of course different: For classes that require allocation, the user has to provide an explicit destructor to make sure resources are released when done with the class. When we interact with the Python interpreter, we need to be cognizant of the difference. With few exceptions, all interactions with the interpreter generate PyObject pointers. While totally opaque from the point of view of C++, they can be classified in three categories: "New", "Stolen" and "Borrowed" (these is Python lingo). "New" objects are generated by the interpreter and are passed to C++, e.g. as the return value of a function. When done with the object, they need to be disposed of property, by calling Py_DECREF() on them. If there is a chance that the object may be a null pointer (e.g., when returning from a Python function that does return something), use Py_XDECREF() instead. "Stolen" objects are objects that are included in compound structures: e.g., when we pack a bunch of PyObjects into a tuple to be passed to a function. Typically this happens with XXX_SetItem() calls. The "stolen" objects will be released when the structure they have been included into is Py_DECREF().
In other words, Py_DECREF descends into each object and checks if their ref count is zero. If so, they are zapped.  
The trickiest objects are the "borrowed" ones. These are objects that have been gotten from another object, typically with a XXX_GetItem() call. If we are planning to hold on the object for a while, during which there is a potential for the other object to get zapped, we need to increase the reference count of the borrowed object, to prevent from being zapped should the original owner be zapped. We do this by Py_INCREF(). 

If all of this sounds confusing, it is because it is. For this reason, the best course of action is not to have PyObjects loose in the C++ code. Thus, by design PyGlue hides all references to PyObjects. The public functions only deal with non PyObjects. That way, hopefully, we can keep tab on the PyObjects and avoid momery leaks and dangling pointers. 

# Error management

The Python  interpreter adds another layer of possible snafus. It is therefore important to handle exceptions properly. 
In this library, we adopt two strategy. First, when we have reason to suspect that something wrong happened on the Python side, e.g. when we get a null pointer instead of a good one, or PyErr_Occurred()=true, we use PyErr_Print() to print the errors as reported by the interpreter. We also have a function Py::lintcatcher() that is designed to catch the exceptions, print some context from the C++ side, and exit if needed. The lintcatcher falls back on a separate class to handle how to print messages and to exit (MayDay). This to make it easy to interface with existing libraries for error handling (e.g., by stopping gracefully MPI runs, or output more diagnostic,...). We provide a simple implementation in MayDay.H. 

Due to the nature of template metaprogramming, it is not 
advisable to continue a program after an exception has raised: you never know what the compiler has prepared for you. Just exit and fix the problem.  

